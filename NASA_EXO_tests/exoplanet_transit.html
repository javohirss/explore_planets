<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exoplanet Transit Detection - Interactive Tutorial</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 100%);
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        h1 {
            color: #4a9eff;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(74, 158, 255, 0.5);
        }

        .subtitle {
            color: #a0a0a0;
            font-size: 1.1em;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            color: #4a9eff;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        #orbitCanvas {
            width: 100%;
            background: #000;
            border-radius: 8px;
            display: block;
            box-shadow: 0 0 30px rgba(74, 158, 255, 0.3);
        }

        #lightCurveCanvas {
            width: 100%;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
        }

        .controls {
            grid-column: 1 / -1;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }

        .control-group {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group label {
            display: block;
            color: #4a9eff;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
        }

        .control-group input[type="number"],
        .control-group select {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #e0e0e0;
            font-size: 0.95em;
        }

        .value-display {
            color: #fff;
            font-weight: 600;
            margin-top: 5px;
            font-size: 0.9em;
        }

        .unit {
            color: #a0a0a0;
            font-size: 0.85em;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4a9eff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(74, 158, 255, 0.5);
        }

        .stats {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-box {
            background: rgba(74, 158, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #4a9eff;
        }

        .stat-label {
            color: #a0a0a0;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #fff;
            font-size: 1.3em;
            font-weight: 600;
        }

        button {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(74, 158, 255, 0.3);
        }

        button:hover {
            background: #3a8eef;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 158, 255, 0.4);
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        @media (max-width: 900px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .info-tooltip {
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #4a9eff;
            color: white;
            border-radius: 50%;
            text-align: center;
            font-size: 12px;
            line-height: 16px;
            cursor: help;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üåü Exoplanet Transit Detection</h1>
            <p class="subtitle">Interactive Tutorial - The Transit Method</p>
        </header>

        <div class="main-content">
            <div class="panel">
                <h2>3D View (Interactive Perspective)</h2>
                <canvas id="orbitCanvas" width="600" height="500"></canvas>
                <div class="button-group">
                    <button id="playPauseBtn">‚è∏Ô∏è Pause</button>
                    <button id="resetBtn">üîÑ Reset</button>
                </div>
            </div>

            <div class="panel">
                <h2>Light Curve</h2>
                <canvas id="lightCurveCanvas"></canvas>
                <div style="margin-top: 15px; color: #a0a0a0; font-size: 0.9em;">
                    The light curve shows stellar brightness over time. When the planet passes between us and the star (transit), 
                    we observe a characteristic dip in brightness. This is what astronomers detect with telescopes!
                </div>
            </div>

            <div class="controls panel">
                <h2>Control Parameters</h2>
                <div style="margin-bottom: 15px; padding: 10px; background: rgba(74, 158, 255, 0.1); border-radius: 5px; border-left: 3px solid #4a9eff;">
                    <strong style="color: #4a9eff;">üí° 3D Rotation:</strong> 
                    <span style="color: #e0e0e0;">Use View Azimuth (horizontal) and View Elevation (vertical) sliders to rotate your perspective around the star system. 
                    Or click preset buttons for common views!</span>
                </div>
                <div class="control-grid">
                    <div class="control-group">
                        <label>Star Radius <span class="info-tooltip" title="Size of the host star">?</span></label>
                        <input type="range" id="starRadius" min="30" max="100" value="60" step="5">
                        <div class="value-display">
                            <span id="starRadiusValue">60</span> <span class="unit">pixels (1.0 R‚òâ)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Planet Radius <span class="info-tooltip" title="Size of the exoplanet">?</span></label>
                        <input type="range" id="planetRadius" min="5" max="40" value="15" step="1">
                        <div class="value-display">
                            <span id="planetRadiusValue">15</span> <span class="unit">pixels (0.10 R‚òâ)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Orbital Radius <span class="info-tooltip" title="Semi-major axis of orbit">?</span></label>
                        <input type="range" id="orbitalRadius" min="120" max="280" value="200" step="10">
                        <div class="value-display">
                            <span id="orbitalRadiusValue">200</span> <span class="unit">pixels (0.05 AU)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Orbital Period <span class="info-tooltip" title="Time for one complete orbit">?</span></label>
                        <input type="range" id="orbitalPeriod" min="2" max="20" value="8" step="0.5">
                        <div class="value-display">
                            <span id="orbitalPeriodValue">8</span> <span class="unit">seconds (4.2 days)</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Orbital Inclination <span class="info-tooltip" title="Angle of orbit (90¬∞ = edge-on)">?</span></label>
                        <input type="range" id="inclination" min="85" max="90" value="90" step="0.5">
                        <div class="value-display">
                            <span id="inclinationValue">90</span> <span class="unit">degrees</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Animation Speed <span class="info-tooltip" title="Speed of the simulation">?</span></label>
                        <input type="range" id="animationSpeed" min="0.2" max="3" value="1" step="0.1">
                        <div class="value-display">
                            <span id="animationSpeedValue">1.0</span> <span class="unit">√ó speed</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <label>Star Temperature <span class="info-tooltip" title="Surface temperature affects color">?</span></label>
                        <select id="starType">
                            <option value="3000">M-type (3000K - Red)</option>
                            <option value="5000">K-type (5000K - Orange)</option>
                            <option value="5778" selected>G-type (5778K - Yellow/Sun)</option>
                            <option value="7000">F-type (7000K - White)</option>
                            <option value="10000">A-type (10000K - Blue-white)</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label>Limb Darkening <span class="info-tooltip" title="Stars appear dimmer at edges">?</span></label>
                        <input type="range" id="limbDarkening" min="0" max="1" value="0.6" step="0.1">
                        <div class="value-display">
                            <span id="limbDarkeningValue">0.6</span> <span class="unit">coefficient</span>
                        </div>
                    </div>

                    <div class="control-group" style="background: rgba(74, 158, 255, 0.1); border: 2px solid #4a9eff;">
                        <label>üîÑ View Azimuth <span class="info-tooltip" title="Rotate view horizontally around the system">?</span></label>
                        <input type="range" id="viewAzimuth" min="0" max="360" value="90" step="1">
                        <div class="value-display">
                            <span id="viewAzimuthValue">90</span> <span class="unit">degrees</span>
                        </div>
                    </div>

                    <div class="control-group" style="background: rgba(74, 158, 255, 0.1); border: 2px solid #4a9eff;">
                        <label>üîÑ View Elevation <span class="info-tooltip" title="Rotate view vertically (0¬∞=edge, 90¬∞=top)">?</span></label>
                        <input type="range" id="viewElevation" min="0" max="90" value="0" step="1">
                        <div class="value-display">
                            <span id="viewElevationValue">0</span> <span class="unit">degrees</span>
                        </div>
                    </div>
                </div>
                <div class="button-group" style="margin-top: 15px;">
                    <button id="sideViewBtn">Side View (Transit)</button>
                    <button id="topViewBtn">Top View</button>
                    <button id="angleViewBtn">Angled View</button>
                </div>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Transit Depth</div>
                    <div class="stat-value"><span id="transitDepth">0.00</span>%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Transit Duration</div>
                    <div class="stat-value"><span id="transitDuration">0.0</span> hrs</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Current Phase</div>
                    <div class="stat-value"><span id="currentPhase">---</span></div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Impact Parameter</div>
                    <div class="stat-value"><span id="impactParam">0.00</span></div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Planet/Star Ratio</div>
                    <div class="stat-value"><span id="radiusRatio">0.00</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const orbitCanvas = document.getElementById('orbitCanvas');
        const orbitCtx = orbitCanvas.getContext('2d');

        // Animation state
        let angle = 0;
        let isPlaying = true;
        let time = 0;
        let lightCurveData = [];
        const maxDataPoints = 100;

        // Parameters
        let params = {
            starRadius: 60,
            planetRadius: 15,
            orbitalRadius: 200,
            orbitalPeriod: 8,
            animationSpeed: 1,
            starTemp: 5778,
            inclination: 90,
            limbDarkening: 0.6,
            viewAzimuth: 90,    // Horizontal rotation (0-360¬∞)
            viewElevation: 0     // Vertical angle (0=edge, 90=top)
        };

        // 3D Rotation and Projection Functions
        function rotatePoint3D(x, y, z, azimuth, elevation) {
            // Convert angles to radians
            const azRad = (azimuth * Math.PI) / 180;
            const elRad = (elevation * Math.PI) / 180;
            
            // Rotate around Y axis (azimuth)
            let x1 = x * Math.cos(azRad) - z * Math.sin(azRad);
            let z1 = x * Math.sin(azRad) + z * Math.cos(azRad);
            let y1 = y;
            
            // Rotate around X axis (elevation)
            let y2 = y1 * Math.cos(elRad) - z1 * Math.sin(elRad);
            let z2 = y1 * Math.sin(elRad) + z1 * Math.cos(elRad);
            let x2 = x1;
            
            return { x: x2, y: y2, z: z2 };
        }

        function projectTo2D(x, y, z, centerX, centerY, scale = 1) {
            // Simple perspective projection
            const perspective = 800;
            const depth = perspective + z;
            const projectedX = centerX + (x * perspective) / depth * scale;
            const projectedY = centerY + (y * perspective) / depth * scale;
            
            return { x: projectedX, y: projectedY, depth: depth };
        }

        // Star color based on temperature (blackbody approximation)
        function getStarColor(temp) {
            if (temp < 3500) return '#ff6b47';
            if (temp < 5000) return '#ffcc66';
            if (temp < 6000) return '#fff4e6';
            if (temp < 7500) return '#f8f8ff';
            return '#aabfff';
        }

        // Calculate brightness considering limb darkening
        function calculateBrightness(planetX, planetY, planetZ, starX, starY, starRadius, planetRadius) {
            const distance = Math.sqrt((planetX - starX) ** 2 + (planetY - starY) ** 2);
            
            // Planet is not in front of star (check z-coordinate)
            if (planetZ > 0 || distance > starRadius + planetRadius) {
                return 1.0;
            }

            // Calculate overlap area with limb darkening
            let totalBlockedFlux = 0;
            const samplePoints = 50;
            
            // Simple limb darkening model: I(Œº) = 1 - u(1 - Œº)
            // Œº = cos(Œ∏) where Œ∏ is angle from center
            const u = params.limbDarkening;
            
            // Calculate total stellar flux
            let totalStarFlux = 0;
            for (let i = 0; i < samplePoints; i++) {
                for (let j = 0; j < samplePoints; j++) {
                    const dx = (i / samplePoints - 0.5) * 2 * starRadius;
                    const dy = (j / samplePoints - 0.5) * 2 * starRadius;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    if (r <= starRadius) {
                        const mu = Math.sqrt(Math.max(0, 1 - (r / starRadius) ** 2));
                        const intensity = 1 - u * (1 - mu);
                        totalStarFlux += intensity;
                    }
                }
            }
            
            // Calculate blocked flux by planet
            if (distance < starRadius + planetRadius && planetZ < 0) {
                for (let i = 0; i < samplePoints; i++) {
                    for (let j = 0; j < samplePoints; j++) {
                        const dx = (i / samplePoints - 0.5) * 2 * starRadius;
                        const dy = (j / samplePoints - 0.5) * 2 * starRadius;
                        const r = Math.sqrt(dx * dx + dy * dy);
                        
                        if (r <= starRadius) {
                            const distToPlanet = Math.sqrt(
                                (starX + dx - planetX) ** 2 + 
                                (starY + dy - planetY) ** 2
                            );
                            
                            if (distToPlanet <= planetRadius) {
                                const mu = Math.sqrt(Math.max(0, 1 - (r / starRadius) ** 2));
                                const intensity = 1 - u * (1 - mu);
                                totalBlockedFlux += intensity;
                            }
                        }
                    }
                }
            }
            
            return Math.max(0, (totalStarFlux - totalBlockedFlux) / totalStarFlux);
        }

        // Draw star with limb darkening
        function drawStar(x, y, radius, color) {
            const u = params.limbDarkening;
            
            // Create radial gradient for limb darkening
            const gradient = orbitCtx.createRadialGradient(x, y, 0, x, y, radius);
            
            // Parse the base color
            const baseColor = color;
            
            // Create gradient stops based on limb darkening
            for (let i = 0; i <= 10; i++) {
                const r = i / 10;
                const mu = Math.sqrt(1 - r * r);
                const intensity = 1 - u * (1 - mu);
                
                // Adjust color brightness
                gradient.addColorStop(r, adjustColorBrightness(baseColor, intensity));
            }
            
            orbitCtx.fillStyle = gradient;
            orbitCtx.beginPath();
            orbitCtx.arc(x, y, radius, 0, Math.PI * 2);
            orbitCtx.fill();
            
            // Add glow
            orbitCtx.shadowBlur = 30;
            orbitCtx.shadowColor = color;
            orbitCtx.beginPath();
            orbitCtx.arc(x, y, radius, 0, Math.PI * 2);
            orbitCtx.fill();
            orbitCtx.shadowBlur = 0;
        }

        // Adjust color brightness
        function adjustColorBrightness(color, factor) {
            // Simple brightness adjustment
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            const newR = Math.min(255, Math.floor(r * factor));
            const newG = Math.min(255, Math.floor(g * factor));
            const newB = Math.min(255, Math.floor(b * factor));
            
            return `rgb(${newR}, ${newG}, ${newB})`;
        }

        // Draw planet
        function drawPlanet(x, y, radius) {
            const gradient = orbitCtx.createRadialGradient(
                x - radius * 0.3, 
                y - radius * 0.3, 
                0, 
                x, 
                y, 
                radius
            );
            gradient.addColorStop(0, '#4a6fa5');
            gradient.addColorStop(0.7, '#2c4870');
            gradient.addColorStop(1, '#1a2940');
            
            orbitCtx.fillStyle = gradient;
            orbitCtx.beginPath();
            orbitCtx.arc(x, y, radius, 0, Math.PI * 2);
            orbitCtx.fill();
            
            // Add subtle outline
            orbitCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            orbitCtx.lineWidth = 1;
            orbitCtx.stroke();
        }

        // Animation loop with 3D rotation
        function animate() {
            if (isPlaying) {
                angle += (2 * Math.PI / (params.orbitalPeriod * 60)) * params.animationSpeed;
                time += params.animationSpeed;
            }

            // Clear canvas
            orbitCtx.fillStyle = '#000';
            orbitCtx.fillRect(0, 0, orbitCanvas.width, orbitCanvas.height);

            const centerX = orbitCanvas.width / 2;
            const centerY = orbitCanvas.height / 2;

            // Calculate planet position in 3D space (original orbital plane)
            const inclinationRad = (params.inclination * Math.PI) / 180;
            
            // Planet position in its orbital plane
            // X-Y plane is the orbit, Z is perpendicular (towards/away from observer initially)
            const orbitX = params.orbitalRadius * Math.cos(angle);
            const orbitY = params.orbitalRadius * Math.sin(angle) * Math.sin(inclinationRad);
            const orbitZ = params.orbitalRadius * Math.sin(angle) * Math.cos(inclinationRad);

            // Apply 3D rotation based on viewing angles
            const rotated = rotatePoint3D(orbitX, orbitY, orbitZ, params.viewAzimuth, params.viewElevation);
            
            // Project to 2D screen space
            const projected = projectTo2D(rotated.x, rotated.y, rotated.z, centerX, centerY);
            const planetX = projected.x;
            const planetY = projected.y;
            const planetZ = rotated.z;

            // Draw orbit path in 3D
            orbitCtx.strokeStyle = 'rgba(74, 158, 255, 0.3)';
            orbitCtx.lineWidth = 2;
            orbitCtx.setLineDash([5, 5]);
            orbitCtx.beginPath();
            
            const pathPoints = 100;
            let orbitPoints = [];
            
            for (let i = 0; i <= pathPoints; i++) {
                const a = (i / pathPoints) * Math.PI * 2;
                const ox = params.orbitalRadius * Math.cos(a);
                const oy = params.orbitalRadius * Math.sin(a) * Math.sin(inclinationRad);
                const oz = params.orbitalRadius * Math.sin(a) * Math.cos(inclinationRad);
                
                const rotatedPoint = rotatePoint3D(ox, oy, oz, params.viewAzimuth, params.viewElevation);
                const projectedPoint = projectTo2D(rotatedPoint.x, rotatedPoint.y, rotatedPoint.z, centerX, centerY);
                
                orbitPoints.push({
                    x: projectedPoint.x,
                    y: projectedPoint.y,
                    z: rotatedPoint.z
                });
            }
            
            // Draw orbit
            orbitCtx.beginPath();
            for (let i = 0; i < orbitPoints.length; i++) {
                const point = orbitPoints[i];
                if (i === 0) {
                    orbitCtx.moveTo(point.x, point.y);
                } else {
                    orbitCtx.lineTo(point.x, point.y);
                }
            }
            orbitCtx.stroke();
            orbitCtx.setLineDash([]);

            // Draw star (always at center)
            const starColor = getStarColor(params.starTemp);
            drawStar(centerX, centerY, params.starRadius, starColor);

            // Draw planet with proper depth ordering
            // Planet is in front if its rotated Z is negative (closer to viewer)
            if (planetZ < 0) {
                // Planet is in front of star
                drawPlanet(planetX, planetY, params.planetRadius);
            } else {
                // Planet is behind the star - make it more transparent
                orbitCtx.globalAlpha = 0.3;
                drawPlanet(planetX, planetY, params.planetRadius);
                orbitCtx.globalAlpha = 1.0;
            }

            // Calculate brightness (based on 2D projected position and depth)
            const brightness = calculateBrightness(
                planetX, planetY, planetZ, centerX, centerY,
                params.starRadius, params.planetRadius
            );

            // Update light curve
            lightCurveData.push({
                time: time / 60,
                brightness: brightness
            });

            if (lightCurveData.length > maxDataPoints) {
                lightCurveData.shift();
            }

            // Update chart
            updateChart();

            // Update statistics
            updateStatistics(brightness, angle, planetX, centerX);

            requestAnimationFrame(animate);
        }

        // Chart setup
        const lightCurveCtx = document.getElementById('lightCurveCanvas').getContext('2d');
        const lightCurveChart = new Chart(lightCurveCtx, {
            type: 'line',
            data: {
                datasets: [{
                    label: 'Relative Brightness',
                    data: [],
                    borderColor: '#4a9eff',
                    backgroundColor: 'rgba(74, 158, 255, 0.1)',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.4,
                    fill: true
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                aspectRatio: 2,
                animation: false,
                scales: {
                    x: {
                        type: 'linear',
                        title: {
                            display: true,
                            text: 'Time (seconds)',
                            color: '#a0a0a0'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: '#a0a0a0'
                        }
                    },
                    y: {
                        min: 0.85,
                        max: 1.01,
                        title: {
                            display: true,
                            text: 'Relative Flux',
                            color: '#a0a0a0'
                        },
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: '#a0a0a0'
                        }
                    }
                },
                plugins: {
                    legend: {
                        labels: {
                            color: '#e0e0e0'
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                return `Flux: ${context.parsed.y.toFixed(4)}`;
                            }
                        }
                    }
                }
            }
        });

        function updateChart() {
            lightCurveChart.data.datasets[0].data = lightCurveData.map(d => ({
                x: d.time,
                y: d.brightness
            }));
            lightCurveChart.update('none');
        }

        // Update statistics
        function updateStatistics(brightness, angle, planetX, centerX) {
            // Transit depth (percentage)
            const transitDepth = ((1 - brightness) * 100).toFixed(2);
            document.getElementById('transitDepth').textContent = transitDepth;

            // Transit duration (hours) - estimated from geometry
            const transitAngle = Math.asin((params.starRadius + params.planetRadius) / params.orbitalRadius);
            const transitFraction = (2 * transitAngle) / (2 * Math.PI);
            const periodDays = params.orbitalPeriod / 10; // rough conversion
            const transitDurationHours = (transitFraction * periodDays * 24).toFixed(1);
            document.getElementById('transitDuration').textContent = transitDurationHours;

            // Current phase
            const normalizedAngle = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            let phase;
            if (brightness < 0.999) {
                phase = 'In Transit';
            } else if (normalizedAngle < Math.PI / 4 || normalizedAngle > 7 * Math.PI / 4) {
                phase = 'Approaching';
            } else if (normalizedAngle > 3 * Math.PI / 4 && normalizedAngle < 5 * Math.PI / 4) {
                phase = 'Behind Star';
            } else {
                phase = 'Out of Transit';
            }
            document.getElementById('currentPhase').textContent = phase;

            // Impact parameter (closest approach to star center in units of stellar radii)
            const impactParam = Math.abs(Math.sin((params.inclination * Math.PI) / 180) - 1);
            document.getElementById('impactParam').textContent = impactParam.toFixed(2);

            // Radius ratio
            const radiusRatio = (params.planetRadius / params.starRadius).toFixed(3);
            document.getElementById('radiusRatio').textContent = radiusRatio;
        }

        // Control handlers
        function setupControls() {
            const controls = {
                starRadius: { param: 'starRadius', display: 'starRadiusValue', suffix: ' pixels' },
                planetRadius: { param: 'planetRadius', display: 'planetRadiusValue', suffix: ' pixels' },
                orbitalRadius: { param: 'orbitalRadius', display: 'orbitalRadiusValue', suffix: ' pixels' },
                orbitalPeriod: { param: 'orbitalPeriod', display: 'orbitalPeriodValue', suffix: ' seconds' },
                animationSpeed: { param: 'animationSpeed', display: 'animationSpeedValue', suffix: '√ó speed' },
                inclination: { param: 'inclination', display: 'inclinationValue', suffix: ' degrees' },
                limbDarkening: { param: 'limbDarkening', display: 'limbDarkeningValue', suffix: '' },
                viewAzimuth: { param: 'viewAzimuth', display: 'viewAzimuthValue', suffix: ' degrees' },
                viewElevation: { param: 'viewElevation', display: 'viewElevationValue', suffix: ' degrees' }
            };

            for (const [id, config] of Object.entries(controls)) {
                const element = document.getElementById(id);
                const display = document.getElementById(config.display);

                element.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    params[config.param] = value;
                    display.textContent = value.toFixed(1);
                });
            }

            document.getElementById('starType').addEventListener('change', (e) => {
                params.starTemp = parseInt(e.target.value);
            });

            document.getElementById('playPauseBtn').addEventListener('click', () => {
                isPlaying = !isPlaying;
                document.getElementById('playPauseBtn').textContent = isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
            });

            document.getElementById('resetBtn').addEventListener('click', () => {
                angle = 0;
                time = 0;
                lightCurveData = [];
                isPlaying = true;
                document.getElementById('playPauseBtn').textContent = '‚è∏Ô∏è Pause';
            });

            // Preset view buttons
            document.getElementById('sideViewBtn').addEventListener('click', () => {
                params.viewAzimuth = 90;
                params.viewElevation = 0;
                document.getElementById('viewAzimuth').value = 90;
                document.getElementById('viewElevation').value = 0;
                document.getElementById('viewAzimuthValue').textContent = '90.0';
                document.getElementById('viewElevationValue').textContent = '0.0';
            });

            document.getElementById('topViewBtn').addEventListener('click', () => {
                params.viewAzimuth = 0;
                params.viewElevation = 90;
                document.getElementById('viewAzimuth').value = 0;
                document.getElementById('viewElevation').value = 90;
                document.getElementById('viewAzimuthValue').textContent = '0.0';
                document.getElementById('viewElevationValue').textContent = '90.0';
            });

            document.getElementById('angleViewBtn').addEventListener('click', () => {
                params.viewAzimuth = 45;
                params.viewElevation = 30;
                document.getElementById('viewAzimuth').value = 45;
                document.getElementById('viewElevation').value = 30;
                document.getElementById('viewAzimuthValue').textContent = '45.0';
                document.getElementById('viewElevationValue').textContent = '30.0';
            });
        }

        // Initialize
        setupControls();
        animate();
    </script>
</body>
</html>

